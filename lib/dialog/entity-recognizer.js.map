{"version":3,"sources":["dialog/entity-recognizer.js"],"names":[],"mappings":"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","file":"dialog/entity-recognizer.js","sourcesContent":["'use strict'\n\nimport chrono from 'node-chrono'\nimport * as utils from '../utils'\n\nconst entityRecognizer = {\n  findEntity (entities, type) {\n    for (let i = 0; i < entities.length; i++) {\n      if (entities[i].type === type) {\n        return entities[i]\n      }\n    }\n    return null\n  },\n  findAllEntities (entities, type) {\n    const found = []\n    for (let i = 0; i < entities.length; i++) {\n      if (entities[i].type === type) {\n        found.push(entities[i])\n      }\n    }\n    return found\n  },\n  parseTime (entities) {\n    if (typeof entities === 'string') {\n      entities = this.recognizeTime(entities)\n    }\n    return this.resolveTime(entities)\n  },\n  resolveTime (entities) {\n    const now = new Date()\n    let resolvedDate = null\n    let date = null\n    let time = null\n    entities.forEach((entity) => {\n      if (entity.resolution) {\n        switch (entity.resolution.resolution_type || entity.type) {\n          case 'builtin.datetime':\n          case 'builtin.datetime.date':\n          case 'builtin.datetime.time':\n            const parts = (entity.resolution.date || entity.resolution.time).split('T')\n            if (!date && this.dateExp.test(parts[0])) {\n              date = parts[0]\n            }\n            if (!time && parts[1]) {\n              time = 'T' + parts[1]\n              if (time === 'TMO') {\n                time = 'T08:00:00'\n              } else if (time === 'TNI') {\n                time = 'T20:00:00'\n              } else if (time.length === 3) {\n                time = time + ':00:00'\n              } else if (time.length === 6) {\n                time = time + ':00'\n              }\n            }\n            break\n          case 'chrono.duration':\n            resolvedDate = entity.duration.resolution.start\n        }\n      }\n    })\n    if (!resolvedDate && (date || time)) {\n      if (!date) {\n        date = utils.toDate8601(now)\n      }\n      if (time) {\n        date += time\n      }\n      resolvedDate = new Date(date)\n    }\n    return resolvedDate\n  },\n  recognizeTime (utterance, refDate) {\n    let response = null\n    try {\n      const results = chrono.parse(utterance, refDate)\n      if (results && results.length > 0) {\n        let duration = results[0]\n        response = {\n          type: 'chrono.duration',\n          entity: duration.text,\n          startIndex: duration.index,\n          endIndex: duration.index + duration.text.length,\n          resolution: {\n            resolution_type: 'chrono.duration',\n            start: duration.start.date()\n          }\n        }\n        if (duration.end) {\n          response.resolution.end = duration.end.date()\n        }\n        if (duration.ref) {\n          response.resolution.ref = duration.ref\n        }\n        response.score = duration.text.length / utterance.length\n      }\n    } catch (err) {\n      console.error(`Error recognizing time: ${err.toString()}`)\n      response = null\n    }\n    return response\n  },\n  parseNumber (entities) {\n    let entity = null\n    if (typeof entities === 'string') {\n      entity = {\n        type: 'text',\n        entity: entities.trim()\n      }\n    } else {\n      entity = this.findEntity(entities, 'builtin.number')\n    }\n    if (entity) {\n      const match = this.numberExp.exec(entity.entity)\n      if (match) {\n        return Number(match[0])\n      }\n    }\n    return Number.NaN\n  },\n  parseBoolean (utterance) {\n    utterance = utterance.trim()\n    if (this.yesExp.test(utterance)) {\n      return true\n    } else if (this.noExp.test(utterance)) {\n      return false\n    }\n    return undefined\n  },\n  findBestMatch (choices, utterance, threshold) {\n    if (threshold === undefined) {\n      threshold = 0.6\n    }\n    let best = null\n    const matches = this.findAllMatches(choices, utterance, threshold)\n    matches.forEach((value) => {\n      if (!best || value.score > best.score) {\n        best = value\n      }\n    })\n    return best\n  },\n  findAllMatches (choices, utterance, threshold) {\n    if (threshold === void 0) {\n      threshold = 0.6\n    }\n    const matches = []\n    utterance = utterance.trim().toLowerCase()\n    const tokens = utterance.split(' ')\n    this.expandChoices(choices).forEach((choice, index) => {\n      let score = 0.0\n      const value = choice.trim().toLowerCase()\n      if (value.indexOf(utterance) >= 0) {\n        score = utterance.length / value.length\n      } else if (utterance.indexOf(value) >= 0) {\n        score = Math.min(0.5 + (value.length / utterance.length), 0.9)\n      } else {\n        let matched = ''\n        tokens.forEach((token) => {\n          if (value.indexOf(token) >= 0) {\n            matched += token\n          }\n        })\n        score = matched.length / value.length\n      }\n      if (score > threshold) {\n        matches.push({\n          index: index,\n          entity: choice,\n          score: score\n        })\n      }\n    })\n    return matches\n  },\n  expandChoices (choices) {\n    if (!choices) {\n      return []\n    } else if (Array.isArray(choices)) {\n      return choices\n    } else if (typeof choices === 'string') {\n      return choices.split('|')\n    } else if (typeof choices === 'object') {\n      const list = []\n      for (let key in choices) {\n        list.push(key)\n      }\n      return list\n    } else {\n      return [choices.toString()]\n    }\n  }\n}\n\nexport default entityRecognizer\n"],"sourceRoot":"/Users/jacopodaeli/Devs/wit-bot-builder/src"}